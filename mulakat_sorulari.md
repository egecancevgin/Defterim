# Egecan Çelik Evgin


## Toplam Çalışma Saati:               380 Saat

## Uzmanlık Seviyesine Giden Yol:      %3.8
 

## Nizami Çalışma Kaydı:
    6 Eylül 2023 Çarşamba:     30 dakika
    7 Eylül 2023 Perşembe:     30 dakika
    8 Eylül 2023 Cuma:         1 saat
    11 Eylül 2023 Pazartesi:   1 saat
    12 Eylül 2023 Salı:        1 saat 30 dakika
    13 Eylül 2023 Çarşamba:    1 saat 30 dakika
    14 Eylül 2023 Perşembe:    2 saat
    15 Eylül 2023 Cuma:        0 dakika
    18 Eylül 2023 Pazartesi:   2 saat
    19 Eylül 2023 Salı:        2 saat 30 dakika
    20 Eylül 2023 Çarşamba:    2 saat 30 dakika
    21 Eylül 2023 Perşembe:    3 saat
    22 Eylül 2023 Cuma:        3 saat
    25 Eylül 2023 Pazartesi:   50 dakika
    26 Eylül 2023 Salı:        2 saat
    27 Eylül 2023 Çarşamba:    0 dakika
    28 Eylül 2023 Perşembe:    0 dakika
    29 Eylül 2023 Cuma:        1 saat 30 dakika
    2 Ekim 2023 Pazartesi:     2 saat
    3 Ekim 2023 Salı:          2 saat 30 dakika
    4 Ekim 2023 Çarşamba:      2 saat
    5 Ekim 2023 Perşembe:      2 saat 30 dakika
    6 Ekim 2023 Cuma:          1 saat 30 dakika
    9 Ekim 2023 Pazartesi:     2 saat
    10 Ekim 2023 Salı:         2 saat 30 dakika
    11 Ekim 2023 Çarşamba:     3 saat
    12 Ekim 2023 Perşembe:     3 saat 30 dakika
    13 Ekim 2023 Cuma:         3 saat
    16 Ekim 2023 Pazartesi:    1 saat
    17 Ekim 2023 Salı:         5 saat 30 dakika
    18 Ekim 2023 Çarşamba:     3 saat 30 dakika
    19 Ekim 2023 Perşembe:     2 saat 30 dakika
    20 Ekim 2023 Cuma:         4 saat 30 dakika
    23 Ekim 2023 Pazartesi:    2 saat 30 dakika
    24 Ekim 2023 Salı:         3 saat
    25 Ekim 2023 Çarşamba:     3 saat 30 dakika
    26 Ekim 2023 Perşembe:     1 saat
    27 Ekim 2023 Cuma:         30 dakika
    30 Ekim 2023 Pazartesi:    4 saat 30 dakika
    31 Ekim 2023 Salı:         3 saat 30 dakika
    1 Kasım 2023 Çarşamba:     4 saat
    2 Kasım 2023 Perşembe:     4 saat 30 dakika
    3 Kasım 2023 Cuma:         3 saat
    6 Kasım 2023 Pazartesi:    7 saat
    7 Kasım 2023 Salı:         6 saat 30 dakika
    8 Kasım 2023 Çarşamba:     6 saat 30 dakika
    9 Kasım 2023 Perşembe:     6 saat
    10 Kasım 2023 Cuma:        5 saat
    11 Kasım 2023 Cumartesi:   1 saat
    12 Kasım 2023 Pazar:       2 saat 
    13 Kasım 2023 Pazartesi:   6 saat 
    14 Kasım 2023 Salı:        10 saat 
    15 Kasım 2023 Çarşamba:    9 saat 
    16 Kasım 2023 Perşembe:    10 saat 
    17 Kasım 2023 Cuma:        8 saat 
    18 Kasım 2023 Cumartesi:   5 saat 30 dakika
    19 Kasım 2023 Pazar:       5 saat
    20 Kasım 2023 Pazartesi:   1 saat
    21 Kasım 2023 Salı:        2 saat
    22 Kasım 2023 Çarşamba:    4 saat 30 dakika
    23 Kasım 2023 Perşembe:    1 saat
    24 Kasım 2023 Cuma:        2 saat
    27 Kasım 2023 Pazartesi:   4 saat
    28 Kasım 2023 Salı:        2 saat
    29 Kasım 2023 Çarşamba:    2 saat 30 dakika
    30 Kasım 2023 Perşembe:    2 saat
    1 Aralık 2023 Cuma:        0 dakika
    2 Aralık 2023 Cumartesi:   2 saat
    3 Aralık 2023 Pazar:       2 saat
    4 Aralık 2023 Pazartesi:   3 saat
    5 Aralık 2023 Salı:        1 saat
    6 Aralık 2023 Çarşamba:    3 saat
    7 Aralık 2023 Perşembe:    2 saat
    10 Aralık 2023 Pazar:      2 saat 30 dakika
    13 Aralık 2023 Çarşamba:   2 saat
    15 Aralık 2023 Cuma:       2 saat
    18 Aralık 2023 Pazartesi:  1 saat
    19 Aralık 2023 Salı:       1 saat 
    20 Aralık 2023 Çarşamba:   5 saat 
    21 Aralık 2023 Perşembe:   5 saat
    22 Aralık 2023 Cuma:       4 saat 
    24 Aralık 2023 Pazar:      1 saat 
    25 Aralık 2023 Pazartesi:  5 saat
    26 Aralık 2023 Salı:       2 saat 
    27 Aralık 2023 Çarşamba:   3 saat
    28 Aralık 2023 Perşembe:   3 saat 
    29 Aralık 2023 Cuma:       3 saat 

## Beceriler:
    Yazılım Geliştirme
    Yazılım Mühendisliği
    Programlama
    Algoritmalar
    Veri Yapıları
    İşletim Sistemleri
    Veri Tabanı Sistemleri
    Yazılım Kalite Güvencesi
    Makine Öğrenmesi
    DevOps
    Çevik Yöntemler
    Bulut Bilişimi
    Dağıtık Sistemler

## Teknik Araçlar:
    C#, ASP.NET Core MVC, Microsoft SQL Server, HTML, CSS, XML, JavaScript, AJAX, jQuery, React, Xunit, Postman, WPF, WCF,
    UML, LINQ, XAML, Angular, Git, Docker, Jenkins, Azure DevOps, TFS/JIRA, JSON, SoapUI, T-SQL, Python, CUDA,
    MongoDB, Redis, PostgreSQL, ELK Stack, Bash, Apache Kafka

## Eğer TT'ye gireresem: 
    Programming with Python, Golang and C++.
    Object Oriented Design and documentation using UML.
    Database Management with PostgreSQL, Apache Cassandra and MongoDB.
    Microservice Management and Monitoring using Apache Kafka, Redis and Jaeger.
    Software and API testing with Selenium and Postman.
    Parallel Computing with C++ and CUDA.
    Machine Learning applications using Scikit-learn, Tensorflow, Pytorch and Hugging Face.
    CI/CD pipeline organization using Jenkins, Gitlab CI/CD.
    Container orchestration using Docker, Kubernetes, Openshift.
    Infrastructure Virtualization using vSphere and Ansible.
    Linux System Administration on Pardus, Red Hat using Bash and Csh.
    Log Management and monitoring using Elastic, Kibana and Logstash.
    Version Controlling and GitOps using Git and ArgoCD.
    MLOps applications using Mlflow and Roboflow.

## Yazılım Mühendisliği Kesin Toollar:
    JavaScript
    HTML
    CSS
    Bootstrap
    SASS
    jQuery
    React
    Node.js
    Express.js
    Redux.js
    Angular
    MongoDB
    T-SQL
    Git
    Docker
    Bash 

## TT Full Stack Developer Toolları:
    Golang, JavaScript, Gin, HTML, CSS, jQuery, Node.js, React, Angular, NestJS, MongoDB, Git, PostgreSQL, Docker, Bash 

## Hedef Projeler:
    E-Ticaret Elektronik Ürünler Öneri Sistemi
    Banka İşlemleri Sahtekarlık Tespiti
    Deployment Anomali Tespiti 
    ATM Ekranı Yazılımı
    TCP Sohbet Odası
    Dil Tespiti Deployment Projesi
    Yazılım Tasarım Desenleri İmplementasyonları
    Algoritmalar ve Veri Yapıları İmplementasyonları
    Profesyonel Full Stack Web Sitesi x2 (Django ve .NET Core MVC)
    Kendi Basit Portfolyo Web Sitem
    CUDA ile Multiprocessing


## Mevcut Okul Derslerimin Soruları (Sonra ele alınacak):
    1- Yazılım Testi nedir, kaça ayrılır? 

    2- Büyük Dil Modelleri nedir, popüler örnekleri nelerdir?
        Generative Pretrained Transformers, Bidirectional Encoder Representations from Transformers, LLama, Bard, Alpaca 
    
    3- Generative AI nedir, hangi modellerden oluşur?
        Yapay zekanın özgün içerikler oluşturduğu tekniklerdir, GPT, BERT, GAN.
    
    4- Difüzyon Modelleri nelerdir, nasıl çalışır?

    5- Autoencoder yapısı nedir?
        Encoder, girdi verisini daha küçük boyutlu, anlamlı ve sıkıştırılmış forma sokar.
        Bottleneck, 
        Decoder, 

    6- Edge Sistemleri nelerdir?
        Merkezi sistem kadar kapasitesi olmayan, akıllı saat, tarzı IoT sistemidir, LLM'ler daha bu sistemlerde çalışamaz.

    7- Agent nedir?
        Yapay zeka botudur, akıllı karar verici birimdir, otonom agent ise otomatik karar verebilen

    8- Vector Database nedir?
        LLM'lerde kullanılan, vektörleri depolamak için kullanılan bir veritabanıdır, ör: Qdrant, Milvus, LlamaIndex, Thistle.

    9- Modelhub nedir?

    10- Multimodal GenAI nedir?
        Multimodal input, hem text hem image hem tabular data olandır.

    11- LangOps nedir?

    12- Retrieval Augmented Generation nedir?

    13- Transfer Learning nedir?
        Eğitilmiş bir modeli başka verilerle fine-tuning etmektir.

    14- Foundation models nedir?

    15- Sentetik veri nedir, nasıl üretilir?

    16- NER nedir?
        Bir cümledeki kelimelerin isim mi şehir mi yemek mi anlayalım diye yapılır.

    17- Fasttext nedir?
        Hem kütüphane, hem de embedding'dir.
    
    18- Docker yapısı VM farkı nedir?
        Hypervisor yerine OS ve Container Engine olur, container'lar ile çalışır yani OS'ten bağımsızdır.
        
    20- Docker Image nedir?
        Container oluşturabildiğimiz şablon tar dosyası, uygulama ve bağımlılıklarını taşınabilir bir paket olarak taşır.

    21- Scalability nasıl olur mikroservislerle, Docker ile?
        Container sayını arttıracaksın, yük azalınca azaltacaksın bir güzel mikroservis-container etkileşimi ile çalışan sistemler.

    22- Docker container'ı nasıl image'a çeviririz?
        Docker commit ile yapılır

    23- Yazılım Testi temel kavramları nelerdir, coverage, td, tp,   falan?

    24- Word2Vec nasıl çalışır?
        Saymaktan çok tahmin etmeye dayalıdır, Ayıkla pirincin (taşını) kardeşim, c1-c2-c3'ü verip, ljk reg ile hedef bulunur.

    25- 1-N 2NF'tir, tabloların PK'sının olması 1NF, ... 3NF'tir.
        Database testing, 3'e ayrılır, Structural-Functional-Non-Functional testing.
        Unit test bir structural testtir, functional test ise black box testtir.
    
    26- Kalite nedir?
        Hız, Güvenlik, Load test, 

    27- Branch nedir ve Branch coverage için test gereksinimleri nedir?
        Bir branch, düz giden grafın aniden iki parçaya ayrılmasıdır, buna branch deriz.
        Gereksinim tüm branchlerdir, coverage ölçüsü de executed branchler / tüm branchlerdir.

    28- EPC ve EC nedir?
        Edge Coverage, yazılımın kontrol akışındaki her bir kenarın en az bir kez yürütüldüğünü doğrulamayı amaçlar.
        Edge Pair Coverage, programın kontrol akışındaki her bir kenar çiftinin en az bir kez yürütüldüğünü kontrol eder.

    29- T-SQL'de `VIEW`, `UDF` ve `SP` Kavramları:
        Değişkenler `DECLARE @SAYI AS INT` şeklinde tanımlanabilir ve `SET @SAYI = 15` şeklinde de değiştirilebilir.
        Global değişkenler `@@` ile tanımlanır, ör: @@FETCH_STATUS = 0.
        `VIEW`'lar bir veya birden fazla tablodan SELECT sorgusu çekerek oluşan veri setinin tablo gibi kullanılmasıdır.
            Diskte yer kaplamazlar çünkü arkada veriyi tutmazlar sadece sorguyu tutarlar.
            Verinin bir kopyasını da oluşturmazlar, tüm veriyi çekmek yerine ilgili veriyi çekip hızlı çalışır.
            Örnek kullanım:
                CREATE VIEW RAPORUM
                AS 
                SELECT ...
                ...
                SELECT * FROM RAPORUM
            Dinamik View, veri tabanına bir view nesnesi oluşturmadan ve bir view gibi kullanıldığı senaryodur.
                Örnek kullanım:
                    SELECT ... FROM 
                    (
                        SELECT ...
                    ) T
                Böylece T'yi çağırdığımızda kodu tekrar yazmak zorunda değiliz.
            ! VIEW içerisinde ORDER BY kullanılamaz.
        `UDF`'ler içine parametre alan veya almayan ve sonuç döndüren nesnelerdir.
        Scalar valued ve Table valued olmak üzere iki çeşittir, sorgu içerisinde kullanılabilir ve her satır için çalışabilir.
        UDF'lerin içerisinde `INSERT-UPDATE-DELETE` kullanılmaz sadece SELECT'ler kullanılabilir.
        VIEW'lardan farklı olarak içerisinde değişken tanımlanabilir ve bu değişkenlere değer atanabilir.
        VIEW'lar satır satır çalışmaz subquery olarak çalışır ve içerisinde değişken tanımlanamaz.
        Örnek kullanım:
            CREATE FUNCTION DBO.TOPLA(@SAYI1 AS INT, @SAYI2 AS INT)
            RETURNS INT
            AS 
            BEGIN
                RETURN @SAYI1 + @SAYI2
            END 
            ...
            SELECT DBO.TOPLA(10, 15)
        Table-valued fonksiyonlar da inline ve multi-statement olarak ikiye ayrılırlar, MSTVF'lerde INSERT-UPDATE yapılabilir.
        Birden fazla T-SQL kodunun birlikte yazılıp, sunucu üzerine derlenerek kaydedildiği yapılardır.
        SELECT-INSERT-UPDATE-DELETE işlemleri, değişken tanımlama, döngü oluşturma, if kullanma, dosya okuma vey yazma yapılabilir.
        Başka bir SP'yi, fonksiyonu ya da view'ı kendi içerisinden de çağırabilir, web servislerine bağlanabilir.        
        AD-HOC Query'lerde yapılan parse etme optimize etme compile etme aşamalarını atlar ve sadece execute edilir.
        SP'ler AD-HOC Query'lerden daha hızlılardır, sorgular network hızında değil ram hızında çalışır.
        SQL Injection saldırılarına karşı kesin çözümdür, zararsız sorgular arasına zararlı sorguların saklandığı durumdur.
        Kritik raporlar için SP bazında yetki verilebilir, `CREATE PROC` şeklinde de oluşturulabilir.
        Örnek Kullanım:
            CREATE PROCEDURE SP_GETSALES
            @CITY 
            AS 
            SELECT * FROM SALES WHERE CITY = @CITY
            ...
            EXEC SP_GETSALES @CITY = 'ISPARTA'
        SP çağırırken yanına WHERE şartı gönderemeyiz VIEW'lardaki gibi, onun yerine parametre olarak verebiliriz.
        Cursor, bir sorgu içerisinde döngü ile satır satır dolaşmak ve işlem yaptırmak için kullanılır.
            Değişkenler tanımlanır ve her bir satır için bu değişkenler tablodan dönen değerlere atanır.
            Örnek Kullanım (Başında '@' kullanılmaz):
            DECLARE CRS CURSOR FOR 
            ...
            OPEN CRS 
            FETCH NEXT FROM CRS INTO @ID, @NAME ...
            CLOSE CRS 
            DEALLOCATE CRS 
        Temp Table'lar, #TabloAdı şeklinde oluşturulur, yine globalse ##Tabloadı, karmaşık sorguları için yazılır.
        PIVOT sütunları satıra, satırları sütuna çevirip özet tablo oluşturmayı sağlar, ör kullanım: PIVOT( ... ) AS PVT.

    30- `OSI` Referans Modeli:
        Open Systems Interconnection referans modeli, bilgisayar ağlarındaki iletişimi yedi farklı katmana bölen standarttır.
        Katmanları şunlardır:
            1- Physical Layer, 
            2- Data Link Layer,
            3- Network Layer,
            4- Transport Layer,
            5- Application Layer, 
            6- Sunum Katmanı,

    31- Yazılım Geliştirmede `CSS`:
        Cascading Style Sheets, web sayfalarının görünümünü ve düzenini kontrol etmek için kullanılan bir stil dilidir.
        `text-align`, bir öğenin içindeki metnin yatay hizalamasını belirler, ör: "left", "center", "right", "justify".
        `background-color`, bir öğenin arka plan rengini belirler, ör: body { background-color: brown }.
        `width`, bir öğenin yatay boyutunu yani genişliğini tanımlar,   ör: benimDiv { width: 300px; }.
        /* ... */, CSS dilinde yorum satırları oluşturmak için kullanılır, `border-color` da öğenin kenarlarını renklendirir.
        `margin-left`, `right-top-bottom`, CSS'de bir öğenin sol ve sağ kenarlarına uygulanan dış boşlukları belirlemeye yarar.
              Ör: margin: 10px auto; dersek `top` ve `bottom` kısımları 10px ile, `left` ve `right` kısımları auto olur.
        `background-image`, CSS'de bir öğenin arka planına eklenen bir görseli belirler, ör: background-image: url(...).
        `padding`, öğenin kenarlardan uzaklığını ayarlamaya yarar, ör: padding: 30px; veya padding-top: 20px;.
        `font-family`, yazı tipini ayarlamayı sağlar, ör: font-family: sans-serif;.
        `<hr>` elemanının da uzunluğu ayarlanabilir, örnek: hr { height: 20px; }.
        Ziyaret edilmiş linkin renginin değişmesi: a:visited {...}, mouse yaklaşınca: a:hover {...}, basılınca: a:active {...}.
        `rgb()` fonksiyonu, R-G-B (0-255) bileşenlerini kullanarak bir renk tanımlamanıza olanak tanır, ör: rgb(20, 50, 56).
             Renklerin on altılık kodlarla temsil edilmesi de oldukça yaygındır, ör: #00FF00 (Tamamen yeşil).
        `hsl()` fonksiyonu, `hue-saturation-lightness` parametreleri ile renk temsilidir, 0-120-240 RGB değerleridir.
             Ör: background-color: hsl(120, 100%, 50%);
        `linear-gradient()` fonksiyonu, bir elemanın arka planına lineer renk geçişi oluşturmak için kullanılır.
             Ör: background-color: linear-gradient(to right, red, green); ya da linear-gradient(90deg, rgb(...), rgb(...),..);
        `opacity`, transparanlık ve opaklık ayarlamaya yarar, ör: opacity: 0.5;, `rgba` ise `rgb()`'ye `alpha`'nın eklenmesidir.
             Ör: display: block; dersek bu öğe kendini tek satırda blok olarak tutar.
        `box-shadow`, bir öğenin kutu modeline göre gölgesini eklemeye yarar, ör: box-shadow: 5px 5px 5px grey;.
        
       
    32- İşletim Sistemlerinde `Bash` dili:
    
    33- `Binary Search Tree` Veri Yapısı:   
    
    34- `Cyclomatic Complexity` ve `Birim Testleri`:
        Anlaşılması zor mu değil mi onu ölçmeye yarar, VS'da `Analyze` kısmına tıklayarak kodun analizini çalıştırabiliriz.
        Visutin programı graf oluşturmaya yarayabilir, CFG oluşturmaya, yine VS'da calculate code metrics ile CC'ye bakarız.
        Normal CC seviyesi birim olarak 10'un aşağısında olmalıdır.
        'if'lerin sayısı `n` ise 2^n tane gidilebilecek graf yolu vardır.
        Bypass Testing, orphan page testi yapılır, hyperlink'lerin fare işaretçi değişimine bakılabilmesi lazım.
        Responsiveness testing ile bir sürü aygıt için grafik testi yapılabilir.
        
    35- Programlamada `Adres`, `İşaretçi`, `Referans` ve `Bitwise Operator` kavramları:
        Fiziksel Adres,
        Sanal Adres,
        `*`
        `&`
        `&`, bitwise OR işlemi,
        `<<`,
        `>>`, 


# Sözel Mülakat Soruları:
<br></br>

## 1- `Yazılım Geliştirme Yaşam Döngüsü`:

 - Planlama: Müşteri gereksinimleri, ihtiyaç analizi ve proje kapsamı bu aşamada yer alır.
   
 - Tasarım: İhtiyaç analizi sonuçlarına dayanarak sistem tasarlanır, dokümentasyon hazırlanır.
   
 - Geliştirme: Kodlama aşamasıdır, yazılımın gerçekten oluştuğu yerdir, tasarım baz alınarak yazılım geliştirilir.
   
 - Test: Yazılımın doğru çalıştığını ve gereksinimleri karşıladığını doğrulama testleri yapılır, hatalar giderilir.
   
 - Dağıtım: Entegrasyon yapılır, yazılım hedef sistemlere yüklenir, müşteri kullanımına açılır.
   
 - Bakım: Yazılım kullanıldıkça oluşan hatalar düzeltilir, performans izleme ve müşteri destek hizmetleri sağlanır.

<br></br>
## 2- Nesne tabanlı programlamada `Arayüzler`:

   - Arayüzler bir sınıfa belirli işlevleri kazandırmak için kullanılır, birden fazla arayüzden miras alınabilir.
   
   - Bir sınıf, bir arayüzden miras aldığında, o arayüzde tanımlanan tüm yöntemleri uygulamak zorundadır.
   
   - Arayüzler yalnızca metot imzalarını içerirler, soyut sınıflarda ise gövdeler de bulunabilir.
   
   - Sadece `public` veya `internal` erişimlerini alabilirler, metotları ise varsayılan olarak public'tir.
   
   Örnek Tanım:
   ``` cs
   public interface IBank
   {
        void MoneyTransfer();
   }
   ```

<br></br>
## 3- İşletim sistemlerinde `TCP` ve `UDP` kavramları:

   - Transmission Control ve User Datagram Protocol, bilgisayar ağlarında veri iletişimini sağlayan iletişim protokolüdür.

   - TCP güvenlilirdir ve bağlantı odaklıdır, veri paketleri sıralı bir şekilde iletilir, UDP'de yoktur, daha hızlıdır.
    
   - 3-way ve 4-way handshake'lerle bağlantı başlatma ve bağlantı sonlandırma yapılır, UDP'de veriler kaybolabilir.
    
   - Başlangıçta istemci sunucuya SYN gönderir, sunucu kabul eder ve SYN-ACK yanıtı verir, istemci bunu alır ve ACK gönderir.
    
   - Sonlandırırken de istemci FIN paketi gönderir, sunucu ACK yanıtlar, sonra FIN gönderir, istemci de ACK yanıtı gönderir.
    
   - TCP, web sayfalarına erişim, dosya aktarımı, mail aktarımı gibi alanlarda kullanılır.
    
   - UDP, çevrimiçi oyunlar, video konferansları, internet üzerinden sesli aramalar gibi alanlarda kullanılır. 

<br></br>
## 4- Nesne tabanlı programlamada `SOLID` prensipleri:

   - SOLID prensipleri, nesne tabanlı programlamada yazılım tasarımını daha sürdürülebilir ve bakımı kolay hale getirir.

   - Single Responsibility, bir sınıfın veya modülün yalnızca bir sorumluluğunun olması gerektiğini belirtir.
    
   - Open-Closed, yazılımın geliştirilebilir olmasını ancak var olan sınıfların kodunun değiştirilmeden yapılmasını belirtir.
    
   - Liskov Substitution, bir alt sınıfın, üst sınıfı yerine kullanılabilmesi ve aynı görevleri yapabilmesini belirtir.
    
   - Interface Segregation, genel arayüzler yerine daha özelleştirilmiş, spesifik ihtiyaçlar için arayüzler olmasını söyler.
    
   - Dependency Inversion, yüksek seviyeli modüllerin, düşük seviyeli modüllere bağımlılıklarının olmaması gerektiğini söyler.

<br></br>
## 5- Nesne tabanlı programlamada `Soyut Sınıflar`:
   
   - Soyut sınıflar, diğer sınıfların temelini oluşturan sınıflardır ve somut nesneler oluşturmak için kullanılamaz.
   
   - Miras alan sınıflar için bir şablondur, soyut metotların gövdeleri yoktur ve bunlar miras alan sınıfta uygulanmalıdır.
   
   - Bir soyut sınıfın içerisinde soyut-somut bir sürü metot bulunabilir, ayrıca bir arayüzden de miras alabilir.
   
   - Bir soyut sınıf, başka bir soyut sınıftan miras alabilir, ancak bir statik sınıfa miras veremez de ondan alamaz da.
   
   - Soyut metotlar, alt sınıfta `override` edilmelidir, yalnızca bir soyut sınıf içerisinde tanımlanabilirler.
   
   - Sanal metotların farkı ise alt sınıfta opsiyonel olarak `override` edilebilmeleridir ve üst sınıfta uygulanabilmeleridir.
   
   - C#, Java gibi dillerde yalnızca bir soyut sınıf miras alınır, Python, C++ ve Rust gibi dillerde birden fazla alınabilir.
   
   Örnek kullanımı:
   ``` cs
     public abstract class Banka
     {
          public abstract void ParaTransferi();
     }
   ```

<br></br>
## 6- Yazılım Mühendisliğinde `Scrum`:
   - Scrum, bir proje yönetimi çerçevesidir, esnek ve işbirlikçi bir yaklaşımı benimser.
 
   - Temel amacı değişen gereksinimlere daha iyi adapte olmak ve müşteri odaklı çalışmaktır.
   
   - Product Owner, Scrum Master ve Geliştirme Ekibinden oluşur, 2 haftalık `sprint`ler ile ürün parçacığı teslim edilir.
   
   - 15 dakikalık Daily Scrum, Sprint Planlama, Sprint Retrospektifi toplantıları ile bir iterasyon yapılır.
   
   - Product Backlog görev ve gereksinimlerin tutulduğu listedir, Kullanıcı Hikayeleri bir gereksinimi açıklar.
   
   - Sprint Backlog, sprintte gerçekleşecek işlerin listesidir, Scrum Board proje ilerlemesinin görsel takibini sağlar.
   
   - Burn-Down Chart, sprint sırasında tamamlanması gereken işlerin kalan miktarını zaman içinde gösteren grafiktir.
   
   - Definition of Done, bir işin bitişini ve kabul edilebilir olduğunu belirleyen listedir ve her KH için bir DoD olmalıdır.
   
   - Efor, görevin tamamlanması için gereken tahmini çalışma süresidir, Velocity ise sprint boyunca tamamlanan efordur.
   
   - Burn-Up Chart, sprintte tamamlanan iş miktarıdır, Hazır Tanımı da bir görevin ekip tarafından bakılmaya hazır olmasıdır.

<br></br>
## 7- Nesne Tabanlı Programlamada `Erişim Belirteçleri`:
   
   - Erişim belirteçleri, sınıf üyelerine ve sınıflara erişimi düzenler ve ilişkileri yönetir.
   
   - Public, tüm erişim seviyelerinin en açık olanıdır, herkesin bu üyeye erişmesine izin verilir.
   
   - Private, yalnızca aynı sınıf içerisinden erişime izin verir, diğer sınıflar ve kodlar bu üyelere erişemezler.
   
   - Protected, aynı sınıf veya alt sınıflardan erişime izin verir, miras alınan sınıfların hiyerarşisinde kullanılır.
   
   - Internal, yalnızca aynı derleme içinden erişime izin verir, bu C# dilinde kullanılırken Java'da Default olarak bilinir.
   
   - Friend, private olan sınıf üyelerine erişimi sağlar, yalnızca C++ dilinde kullanılır.
   
   - C# dilinde protected internal ve private protected da vardır, varsayılan olarak sınıflar internal, üyeler private'dır.
   
   - Java'da default hem sınıflarda hem üyelerde varsayılan belirteçtir, C++ dilinde ise hem sınıflar hem üyeler private'dır.

<br></br>    
## 8- Makine Öğrenimi Temel Aşamaları?
   
   - Representation, verilerin temsil edildiği ve makine öğrenimi modelinin oluşturulup bu temsille öğrendiği aşamadır.
   
   - Feature Engineering, boyut azaltma ve matematiksel algoritmaların seçimleri bu aşamada gerçekleştirilir.
   
   - Evaluation, modelin performansının objektif bir şekilde uygun metriklerle ölçüldüğü aşamadır.
   
   - Bu metrikler accuracy, precision, recall, F1-score, ROC eğrisi, AUC olabilir ve bunlara karmaşa matrisinden bakılabilir.
   
   - Optimization, modelin performansını iyileştirmek amacıyla bazı ayarların yapıldığı ve yeniden düzenlendiği aşamadır.
   
   - Hiperparametre ayarı, overfitting-underfitting tespiti, aktivasyon fonksiyonları, regularization yapılabilir.

<br></br>
## 9- `Binary Search` Algoritması:
   - İkili arama algoritması, decrease and conquer tasarım paradigmasına uyan bir arama algoritmasıdır.
   - Orijinalde sıralı olan bir dizi içerisinde belirli bir elemanı arar, diziyi her seferinde ikiye bölerek çalışır.
   - Lineer arama algoritmasının karmaşıklığı en kötü durumda O(n) iken, ikili arama algoritması bunu O(logn)'e düşürür.
   Örnek kullanımı:
   ``` cs
   static int BinarySearch(int[] arr, int target)
   {
        int lo = 0, hi = arr.Length - 1;
        while (lo <= hi)
        {
             int mid = lo + (hi - lo) / 2;
             if (arr[mid] == target)
                  return mid;
             if (arr[mid] < target)
                  lo = mid + 1;
             else
                  hi = mid - 1;
        }
        return -1;
   }
   ```
<br></br>    
## 10- Nesne tabanlı programlamada `Polimorfizm` kavramı:
   - Polimorfizm, farklı nesnelerin aynı şablonu kullanarak farklı şekillerde davranabilmesidir.
   - Derleme zamanı ve koşu zamanı polimorfizmi olarak ikiye ayrılır.
   - Derleme zamanı polimorfizmi aynı zamanda statik polimorfizm olarak da ifade edilir, overloading işlemidir.
   - Overloading işlemi metot overloading ve operator overloading olarak da ikiye ayrılır.
   - Koşu zamanı polimorfizmi aynı zamanda dinamik polimorfizm olarak da ifade edilir, override işlemidir.
   Örnek kullanımlar:
   ``` cs
   public int Topla(int s1, int s2) { ... }    
   public int Topla(int s1, int s2, int s3) { ... }                      // Method overloading
   ...
   public static KarmaşıkSayı operator +(Complex c1, Complex c2) { ... } // Operator overloading
   ...
   public override AlanHesabı(int yarıçap) { ... }                       // Method overriding
   ```

<br></br>    
## 11- SQL dilinde `JOIN` kavramı:
 
   - `JOIN`, verileri birden fazla tablodan çekmeye ve tablolar arasındaki ilişkileri kullanarak birleştirmeye yarar.
   - `INNER JOIN`, belirtilen iki tabloda eşleşen satırları getirir, yalnızca iki tablonun ortak satırlarını döndürür.
   - `LEFT JOIN`, ilk yani sol tablodaki tüm satırları ve bu satırların eşleştiği sağ tablodaki satırları getirir, yoksa NULL.
   - `RIGHT JOIN`, operatörün sağ tarafındaki (ikinci) tüm satırları ve bu satırların eşleştiği sol tablo satırlarını döner.
   - `FULL OUTER JOIN`, her iki tablonun da tamamını getirir, eşleşen satırları ve eşleşmeyen satırları içerir.
   - `CROSS JOIN`, belirtilen tablolar arasındaki tüm olası kombinasyonları üretir, her satırı her diğer satırla eşleştirir.
   Örnek sonuç, bir tabloda Berna-Esra satırları olsun bir tabloda da Ege-Emine satırları olsun, bunların cross join'i:
   
   Berna-Ege, Berna-Emine, Esra-Ege, Esra-Emine...
   
   - `SELF JOIN`, aynı tablo içindeki farklı sütunları birbiyle ilişkilendirmek için kullanılır.
   Örnek kullanımlar:
   ``` sql
   SELECT Orders.OrderID, Customers.CustName FROM Orders INNER JOIN Customers ON Orders.CustID = Customers.CustID;
   SELECT Employees.EmpName, Orders.OrdID FROM Employees LEFT JOIN ON Employees.EmployeeID = Orders.EmployeeID;
   SELECT Employees.Empname FROM Employees RIGHT JOIN ON Employees.EmployeeID = Orders.EmployeeID;
   SELECT Customers.CustName, Orders.OrdID FROM Customers FULL OUTER JOIN Orders ON Customers.CustID = Orders.OrdID;
   SELECT Tablo1.Sutun1, Tablo2.Sutun2 FROM Tablo1 CROSS JOIN Tablo2;
   SELECT c1.Ad AS ClsnIsmi, c2.Isim AS YnticiIsmi FROM Calisanlar c1 LEFT JOIN Calisanlar c2 ON c1.YntID = c2.ClsID;
   ```

<br></br>
## 12- Makine Öğreniminde `Lineer Regresyon` ile `Lojistik Regresyon` Algoritmaları:
   - Lineer Regresyon, bir dizi noktaya en uygun düz çizgiyi bulmak için kullanılır, sürekli değerleri tahmin eder.
   - Öğrenme denklemi: y' = b + w1x1 + w2x2 + ... + wnxn şeklindedir, b: bias, w: ağırlık, x: veri noktasıdır.
   - Loss, bir modelin bir örnekteki tahmininin hatasıdır ve tamamen doğru bir tahmin için sıfır değerini alır.
   - Mean Squared Error, lineer regresyon için popüler bir kayıp fonksiyonudur.
   - MSE, gözlemlenen ve tahmin edilen değerler arasındaki farkı ölçer ve karesini alır.
   - Lojistik Regresyon, sınıflandırma problemlerini çözmek için kullanılan bir algoritmadır.
   - Tam olarak 0 veya 1'i tahmin etmek yerine bir olasılık üretir, ayarlanmış bir eşik değer ile tahmin yapılır.
   - Sigmoid aktivasyon fonksiyonu sayesinde çıktının her zaman 0-1 arasında olması sağlanır (y = 1 / (1 + e^-z)).
   - LR'un kayıp fonksiyonu log loss'tur ve şu şekilde tanımlanır: sum(x, y){ -y*log(y') - (1-y)*log(1-y') }.
   - Threshold yükselirse yüksek ihtimalle precision düşer, recall artar ve düşürülürse de tam tersi.
   Örnek kullanım:
   ``` python
   from sklearn.linear_model import LinearRegression, LogisticRegression
   model = LinearRegression()
   model.fit(X, y)                      # X: Bağımsız değişkenleri, y: Bağımlı değişkeni belirtir
   y_pred = model.predict(Z)
   ...
   model = LogisticRegression()
   model.fit(X_train, y_train)
   y_pred = model.predict(X_test)
   ```
 
<br></br>
## 13- Nesne tabanlı programlamada `Inheritance`, `Encapsulation`, `Abstraction` kavramları:
   - Inheritance, bir sınıfın başka bir sınıftan özelliklerini ve davranışlarını devralmasını sağlar.
   - Kodun DRY prensibine uymasını sağlar, Multiple, Multilevel, Hiyerarşik Inheritance türleri vardır.
   - Multiple kalıtım birden fazla sınıftan miras almaktır, buna izin veren diller C++, Python, Kotlin, Ruby ve Rust'dır.
   - Multilevel Inheritance bir sınıfın hem bir üst sınıfının hem de bir alt sınıfının olmasıdır.
   - Hiyerarşik Inheritance bir sınıfın birden fazla sınıfa ayrı ayrı miras vermesidir.
   - Encapsulation, sınıfın içeriğini dış dünyadan gizlemeyi ve erişimini kontrol etmeyi hedefler.
   - Bunu gerçekleştirmek için private erişim belirteci ve getter-setter property'ler kullanılabilir.
   - Abstraction, gerekli olmayan özellik ve metotların, yazılım geliştiricinin gözünün önünde bulunmamasını hedefler.
   - Bunu soyut sınıflar ve arayüzlerle gerçekleştirmek mümkündür.
   Örnek kullanım:
   public class KatılımBankası: Banka { ... }             // Inheritance
   ...
   public class KatılımBankası          
   {
        private int TCKimlik;
        public int TCKimlik                                // Encapsulation
        {
             get
             {
                  return TCKimlik;
             }
             set
             {
                  TCKimlik = value;
             }
        }
   }
   ...

<br></br>
## 14- `Bubble Sort` Algoritması:
   - Bubble Sort, bir diziyi sıralamak için bitişik elemanları karşılaştırarak gerektiğinde yer değiştirir.
   - İç döngüde bir tur, en büyük elemanı bulup onu listenin en sonuna koymaya yarar.
   - Her dış döngü turundan itibaren dizi daha da sıralanır.
   - En iyi durumda dizi zaten sıralıdır ve bu durumda zaman karmaşıklığı O(n) olur.
   - En kötü durumda ve ortalama durumda n elemanlı dizi için n*(n-1)/2 karşılaştırma yapılır ve bu O(n^2) yapar.
   - Örnek in-place uygulama:
   ``` cs
   static void BubbleSort(int[] arr)
   {
        bool swapped = false;
        for (int i=0; i<arr.Length-1; i++)
        {
             swapped = false;
             for (int j=0; j<arr.Length-1; j++)
             {
                  if (arr[j] > arr[j+1])
                  {
                       int temp = arr[j];
                       arr[j] = arr[j+1];
                       arr[j+1] = temp;
                       swapped = true;
                  }
             }
             if (!swapped)
                  break;
        }
   }
   ```
<br></br>
## 15- Yazılım Mühendisliğinde `DevOps` ile `CI/CD` Kavramları:
   - DevOps, yazılım geliştirme ve IT operasyonları arasındaki işbirliği arttıran hızlı ve güvenilir bir yaklaşımdır.
   - Plan, Code, Build, Test, Release, Deploy, Operate, Monitor şeklinde 8 adımdan oluşur.
   - Release aşamasında onaylanmış ve test edilmiş yazılımın bir sürümü hazırlanır ve versiyon numarası eklenir.
   - Deploy aşamasında onaylanmış sürümün canlı üretim ortamına dağıtılması olur ve süreç otomatikleşir.
   - Operate aşamasında canlı sistemler işletilir ve yönetilir, kullanıcı destek hizmetleri sunulur.
   - Monitor aşamasında canlı sistemler sürekli olarak izlenir ve performansları ölçülür, hata tespiti ve çözümü gerçekleşir.
   - Release için Jenkins, Travis CI, CircleCI ve Gitlab CI/CD; deploy için Docker, Kubernetes, Ansible kullanılabilir.
   - Son iki aşama için ise Nagios, Spunk, Prometheus, Grafana ve New Relic kullanılabilir.
   - CI/CD, DevOps'un bir alt kavramı olarak düşünülebilir, bu süreçleri optimize ederek hızlı ve sürekli gelişimi sağlar.
   - Sürekli Entegrasyon, kaynak kod değişiklik kontrolü, otomatik derleme ve testler, raporlama prensiplerine dayanır.
   - Sürekli Delivery, yazılımın canlıya teslim edilmesi için hazır olduğu ancak son bir onay bekleyen aşamadır.
   - Sürekli Deployment aşamasında ise yazılım her değişiklik yapıldığında otomatik olarak canlı üretim ortamına dağıtılır.

<br></br>
## 16- `T-SQL` ile `ACID`:
   - Transact-SQL, Microsoft'un hazırladığı, Microsoft SQL Server'da kullanılan bir SQL türevidir.
   - Transaction, SQL sorgularının ve komutlarının gruplandığı bir işlem birimidir.
   - Bir transaction'un ya tamamı başarıyla gerçekleşir ya da hiçbir parçası gerçekleşmez.
   - T-SQL komutları DDL, DML, DQL, DCL ve TCL olarak gruplandırılabilir.
   - Data Definition Language, veri tanımlamaya yarar, ör: CREATE TABLE, ALTER TABLE, DROP TABLE, CREATE INDEX.
   - Data Manipulation Language, veriyi işlemeye yarar, ör: INSERT, UPDATE, DELETE.
   - Data Query Language, verileri sorgular ve çeker, ör: SELECT.
   - Data Control Language, verileri ve izinleri kontrol etmeye yarar, ör: GRANT, REVOKE.
   - Transaction Control Language, transaction'ları kontrol etmeye yarar, ör: BEGIN TRANSACTION, COMMIT, ROLLBACK.
   - ACID, transaction güvenilirliğini ve tutarlılığını sağlamak için kullanılan bir dizi yöntemi ifade eder.
   - Atomicity, bir transaction ya tamamlanır ya da hiçbir şey yapılmaz ilkesini ifade eder.
   - Consistency, bir transaction'dan önce ve sonra veritabanının tutarlı olması gerektiğini ifade eder.
   - Isolation, bir transaction'un diğer transaction'lardan bağımsız ve etkilenmeden çalışmasını sağlar.
   - Durability, başarılı tamamlanan bir işlemin sonuçlarının kalıcı olarak güvence altına alınması gerektiğini ifade eder.
   Örnek Transaction:
   ``` sql
   BEGIN TRANSACTION BankaUpdate;
   UPDATE BankaHesapları
   SET Bakiye = Bakiye + 100
   WHERE HesapNumarası = 234523156;
   COMMIT TRANSACTION BankaUpdate;
   ```

<br></br>
## 17- Yazılım Mühendisliğinde `Versiyon Kontrol Sistemleri`:
   - Versiyon kontrol sistemleri, yazılım geliştirme süreçlerinde kaynak kodunun yönetilmesini sağlayan bir araçtır.
   - Merkezi ve Dağıtık versiyon kontrol sistemleri olarak iki ana kategoriye ayrılır.
   - Merkesi VCS, merkezi bir sunucu üzerinde barındırılan bir repository kullanır, ör: Subversion.
   - Dağıtık VCS, her geliştiricinin yerel bir kopyasının bulunduğu bağımsız depolar kullanır, ör: Git, Mercurial.
   - Git projesinin temeli olan repository, projenin tüm dosyalarını ve geçmiş sürüm geçişlerini içeren bir veritabanıdır.
   - Her Git reposu, local repo ve remote repo olmak üzere iki ana bölümden oluşur.
   - Git projeleri bir main branch ve birden fazla yan branch içerir, gerektiğinde bu dallar main'e merge edilir.
   - İşlem ağacındaki değişiklikler bir sürüm olarak ´commit´ edilerek kaydedilir.
   Örnek Git komutları:
   ``` sh
   git init                  // Yeni bir repository oluşturur.
   git clone <URL>           // Uzak bir repoyu kopyalar ve yerel bir kopya oluşturur.
   git add <dosya>           // İşlem ağacına belirli dosya ekler, bunun bir sonraki commit'e dahil edilmesini sağlar.
   git commit -m "Açıklama"  // Staging area'daki değişiklikleri bir sürüm olarak kaydeder ve açıklama ekler.
   git status                // Staging area ve repo durumunu gösterir, hangi dosyaların değiştirildiğini, ağacı gösterir. 
   git log:                  // Sürüm geçiş geçmişini gösterir, her commit'in kimlik no, yazarı, tarihi ve açıklamasını içerir.
   git branch                // Mevcut dalları ve hangi dalda olduğumuzu görüntüler.
   git checkout <dal>        // Belirli bir dala geçiş yapar veya belirli bir sürüme geri döner.
   git pull                  // Uzak bir depodan son değişiklikleri alır ve yerel kopyayı günceller.
   git push:                 // Yerel depodaki değişiklikleri uzak depoya gönderir.
   git merge <dal>           // Belirli bir dalı main'e birleştirme işlemi gerçekleştirir.
   git fetch                 // Uzak bir repodan değişiklikleri alır ancak yerel kopyayı güncellemez, değişiklikleri gösterir.
   git stash                 // Geçici olarak çalışılan ancak henüz tamamlanmayan değişikliklerin saklanmasını sağlar.
   git cherry pick           // Belirli bir commit'in değişikliklerini başka bir branch'e uygulamak için kullanılır.
   git tag                   // Bir commit'e yapılan adlandırılmadır, git log ise commit durumlarını gözlemlemek için kullanılır.
   git rebase                // Mevcut branch'teki commit geçmişini, belirtilen <base> branch veya commit üzerine uygular.
   git switch                // Belirli bir branch'i seçmek veya başka bir branch arasında geçiş yapmak için kullanılır.
   ```

<br></br>
## 18- `Linux` ile `UNIX`:
   - Linux, özgür yazılım topluluğu tarafından geliştirilen açık kaynaklı bir işletim sistemi çekirdeğidir.
   - GNU General Public License altında dağıtılır, örnek dağıtımları arasında Ubuntu, CentOS, Debian ve Fedora bulunur.
   - Unix, AT&T Bell laboratuvarlarında geliştirilen ticari bir işletim sistemidir, ör: AIX, Solaris, HP-UX.
   - Linux mimarisini donanım, çekirdek, kabuk ve uygulamalar olarak dört ana katmanda inceleyebiliriz.
   - Donanım, bilgisayarın fiziksel bileşenleridir: işlemci, bellek, disk sürücüleri, ağ kartları, I/O aygıtları bulunur.
   - Çekirdek, OS'in merkezi bileşenidir, bellek ve proses yönetimi, sürücü yönetimi, dosya sistemleri, ağ iletişimi.
   - Kabuk, kullanıcı ile OS arasında etkileşim sağlayan bir arayüzdür, yaygın kullanılan kabuklar: Bash, Zsh, Fish.
   - Uygulama, kullanıcıların işlerini gerçekleştirdiği yerdir, metin editörleri, GUI, web tarayıcıları, oyunları içerir.
   - Dosya sistemi hiyerarşik bir yapıya sahiptir ve en üst düzeyi '/' yani kök dizindir, diğerleri bunun altındadır:
   - '/bin', temel sistem komutlarını içeren yürütülebilir dosyaların bulunduğu dizindir, ör: 'ls', 'cp'...
   - '/etc', sistem yapılandırma dosyalarını içerir, örneğin ağ yapılandırma dosyaları, kullanıcı hesapları vardır.
   - '/home', kullanıcıların ev dizinlerini içerir, her kullanıcı burada kişisel dizinini bulur, ör: /home/egecan.
   - '/lib', sistem için gerekli olan kitaplıkları içerir, yürütülebilir dosyalar tarafından kullanılır.
   - '/dev', donanım cihazlarına erişimi, ör: disk sürücüleri (/dev/sda), terminal cihazları (/dev/tty) sağlar.
   - '/var', değişken verileri içerir, log dosyaları, geçici dosyalar ve sistem tarafından düzenlenen diğer veriler.
   - '/tmp', geçici dosyaların depolandığı dizindir, bu dosyalar sistem başlatılınca oluşturulur kapatılınca silinir.
   - '/proc', kernel ve çalışan süreçlere ilişkin bilgileri içerir, bu dizin üzerinden proses bilgilerin erişilebilir.
   - '/sbin', sistem binary, sadece sistem yöneticilerinin kullanabileceği yürütülebilir konfigurasyonları içerir.
   - '/usr', unix sistem resources, sistemle ilgili kaynakları içerir, uygulamaların ve kullanıcılar için belgeler.
   - Sembolik bağlantılar, dosya ve dizinler arasında referans oluşturan özel dosyalardır, daha yavaşlardır.
   - Giriş ve çıkışlar stdin (0), stdout (1) ve stderr (2) olarak ayrılır, file > oufile.txt 2>&1 hem 1 hem 2'yi yollar.
   - /etc/passwd dosyası, kullanıcı adları, kullanıcı kimlikleri, giriş dizinleri ve varsayılan kabuk gibi bilgiler saklar.
   - /etc/shadow dosyası, şifrelenmiş parolaları ve güvenlikle ilgili diğer bilgileri içerir, root tarafından erişilebilir.

<br></br>
## 19- `Containerization` ve `Docker`:
   - Containerization, bir uygulama için gerekli olan tüm bağımlılıkları ve ortamı içeren izole paketler oluşturmaktır.
   - Docker, uygulamaları, bağımlılıkları ve ortamı bir araya getirerek izole konteynerlar oluşturmayı sağlar.
   - Bu konteynerler, Docker runtime üzerinde çalıştırılabilir ve birden çok ortamda tutarlı bir şekilde çalışabilir.
   - Docker Daemon, sistemde arka planda çalışan bir süreçtir ve konteynerleri oluşturur, çalıştırır, durdurur.
   - Docker CLI, komut satırı arayüzüdür, kullanıcının Docker ile etkileşime girmesini sağlar.
   - Docker Image, uygulamanın çalışabilmesi için gerekli her şeyi içeren pakettir, temelde salt okunurlardır.
   - Docker Container, bir Image örneğidir, izole bir ortamda çalışan uygulamayı temsil eder.
   - Docker Registry, Image'ları depolayan ve paylaşan uzak bir depolama alanıdır, ör: Docker Hub.
   - Dockerfile, bir Docker imajının nasıl oluşturulacağını belirten metin dosyasıdır.
   - Docker Compose, birden çok konteyneri ve bunların konfigürasyonlarını tek bir dosyada yönetmeye olanak tanır.  
   Örnek CLI Komutları:
   ``` sh
   docker images komut satırı, sistemde bulunan Docker imajlarını ve bunların özelliklerini listeler.
   docker ps, sistemde çalışan Docker konteynerlarını ve bunların temel bilgilerini gösterir, -a ile inaktifleri de.
   docker pull redis:6.0.10, Docker Hub'dan belirtilen imajı çeker.
   docker login, Docker Hub hesabına giriş yapar.
   docker push egecancevgin/ege.ai:latest, oluşturulan imajı Docker Hub'a iter.
   docker run -p 8080:80 elasticsearch, bir konteyner başlatır, 8080 portunu host makinenin 80 portuna yönlendirir.
   docker stop 9876543210ab, belirli bir konteyneri durdurur.
   docker logs 9876543210ab, belirli bir konteynerin günlük çıktılarını görüntüler.
   docker build -t my_web_app:1.0 . Dockerfile kullanarak bir Docker imajı oluşturur ve etiketler.
   docker-compose up, Compose kullanarak birden fazla konteyneri başlatır, `docker-compose.yml` dosyasını kullanır.
   ```
   Örnek Dockerfile:
   ``` Dockerfile
   FROM python:3.8-slim
   WORKDIR /app
   COPY requirements.txt
   RUN pip install --no-cache-dir -r requirements.txt
   COPY ..
   CMD ["python", "app.py"]
   ```

<br></br>
## 20- Yazılım Mühendisliğinde `NoSQL`:
   - Not Only SQL, ilişkisel olmayan büyük ve dağılmış veri setleri ile çalışmak üzere tasarlanmış veritabanı sistemleridir.
   - Genellikler veritabanına veri eklerken veya çıkarırken bir şema tanımlamaya gerek yoktur.
   - Veri seti büyüdükçe sistem performansını artırmak ve dağılmış ortamlarda çalışmak için yatay ölçeklenebilirlik sağlar.
   - BASE özelliklerini benimserler:
   - Basically Available, veri tabanı sistemi her zaman çalışabilir olmalıdır, aksaklık durumunda bile.
   - Soft State, sistemdeki durum sürekli olarak değişebilir ve bazen düğümler arasında belirsizlik olabilir.
   - Eventually Consistent, sistemdeki kopyaların sonunda aynı olacağı, tutarlılığın zaman içinde oturacağını belirtir.
   - NoSQL veri tabanları dört kategoride incelenebilir:
   - Döküman bazlı, genellikle JSON veya XML formatında yani belge şeklindeki verileri depolar, ör: MongoDB, CouchDB.
   - Key-Value bazlı, her veri öğesi için benzersiz bir anahtar ve bunla ilişkili bir değer içerir, ör: Redis, DynamoDB.
   - Graf bazlı, veriler düğümler ve kenarlar şeklinde temsil edilir, ör: Neo4j, Neptune.
   - Wide-Column, sütunlara dayalıdır, şemasızdır, yatay ölçeklenme sağlar, ör: Cassandra.
   - CAP Teoremi, bir veritabanı tasarım prensibidir, üç ilkenin bir sistemde tamamen bir arada olamayacağını söyler.
   - Consistency, veritabanındaki bilgilerin her durumda tutarlı olması anlamına gelir.
   - Availability, veritabanına her zaman erişebilir olması gerektiğini söyler, hata ve kesintide dahi.
   - Partition Tolerance, ağda oluşabilecek bölünmeler veya iletişim sorunlarına karşı dirençlidir, kesintiye rağmen.
   MongoDB örnek kullanım, ($ bazı operatörleri çağırmaya yarıyor):
   ``` js
   db.createCollection("mycollection")
   db.mycollection.insert({ name: "Egecan", age: 25, city: "Istanbul" })
   db.mycollection.update({ name: "Egecan" }, { $set: { age: 26 } })
   db.mycollection.remove({ name: "Egecan" })
   db.mycollection.find({ age: { $gt: 25 } })
   db.mycollection.createIndex({ name: 1 })
   db.mycollection.aggregate([{ $group: { _id: "$city", count: { $sum: 1 } } }])
   db.stats()
   ```
<br></br>
## 21- Yazılım Mühendisliğinde `Mikroservisler`, `SOA` ve `Monolitik Uygulamalar`:
   Monolitik uygulama, tek bir büyük bütünleşik kod tabanına sahip olan geleneksel bir uygulama mimarisidir.
   - Geliştirme, dağıtım ve ölçeklendirme genellikle bir birim halinde yapılır.
   - Büyüdükçe, geliştirme ve bakım zorlaşabilir, tek bir hata tüm uygulamayı etkileyebilir.
   - Yeniden kullanılabilirlik ve ölçeklenebilirlik konularında sınırlamalar olabilir.
   Mikroservis mimarisi, uygulamayı bağımsız hizmetlere bölerek, her bir hizmetin belirli bir işlevi ele almasını sağlar.
   - Bu hizmetler genellikle küçük, özerk ve bağımsız bir şekilde çalışabilir.
   - Hizmetler genellikle farklı veritabanlarına ve dil/teknoloji yığınlarına sahip olabilir.
   - Her bir hizmet bağımsız olarak geliştirilebilir, dağıtılabilir ve ölçeklenebilir.
   - Dağıtık sistemlerin yönetimi karmaşıktır, iletişim ve ağ maliyetleri artabilir.
   - Başlangıçta kurulum ve yönetim maliyetleri yüksek olabilir, genellikle büyük ölçekli projelerde tercih edilir.
   - Monolitikler genellikle tek bir sunucu üzerinde çalışırken, Mikroservisler farklı sunucularda çalışabilir.
   - Mikroservisler arasında iletişim kurmak için `message broker`'lar kullanılabilir, ör: RabbitMQ, Redis, Kafka.
   - Mikroservis uygulamalarında hizmetler genellikle çoklu örneklerde çalıştığı için yük dengelemeye ihtiyaç duyulur.
   - Service Oriented Architecture, bir uygulamanın bağımsız servisler ile çalışmasıdır ve bunlar aralarında iletişim kurar.
   - Serverless Mimari, altyapının yönetimini geliştiriciden uzaklaştıran ve sadece işlevselliğe odakladığı yaklaşımdır.
   - Event-Driven mimari, olayların gerçekleşmesine dayalı olarak sistemlerin tepki verdiği bir yaklaşımdır.

<br></br>
## 22- `Kuyruk`, `Yığın` ve `Bağlı Liste` Veri Yapıları:
        Kuyruk, FIFO prensibine dayanır, `Breadth First Search` içerisinde kullanılabilir, yani seviye seviye aramadır.
        Basit, dairesel, öncelikli kuyruk gibi türleri, `Enqueue()-Dequeue()-Front()-Rear()-IsFull()` gibi metotları vardır. 
        Yığın, LIFO prensibine dayanır, `Depth First Search` içerisinde kullanılabilir, yani bir yol seç bitene kadar devam.
        Yığının `Push()-Pop()-Peek()-IsEmpty()-Size()` gibi metotları vardır.
        Bağlı Listeler, dinamik veri yapılarıdır, düğümlerden oluşurlar ve ilk düğüm `head` işaretçisi ile gösterilir.
        Her düğüm, bir sonraki düğümün bellek adresini içeren bir referansa sahiptir ve bir de değer saklar.
        Tek yönlü, çift yönlü ve dairesel olmak üzere üç türde incelenebilirler.
        Örnek bağlı liste:
            public class LinkedList
            {
                Node head;
                public class Node
                {
                    public int Value;
                    public Node Next;
                    public Node(int d)
                    {
                        Value = d;
                        Next = null;
                    }
                }
            }

<br></br>
## 23- T-SQL'de Şart Blokları, Döngüler, Trigger ve Index Kavramları:
        Şart blokları, belirli bir koşulu kontrol etmek için kullanılır ör: `IF`, `CASE-WHEN` ve `IIF`.
        `IF` sadece işlemler içerisinde kullanılırken, `CASE-WHEN` sorgu içinde, IIF de sorgularda tek koşulla çalışır.
        Döngüler, bir işlemin birden fazla çalışmasını sağlar, `WHILE`-`GO` komutları kullanılır.
        Trigger, veritabanı tablosunda bir işlem gerçekleştiğinde başka bir işlemin gerçekleşmesi durumudur.
            Bu işlemler `INSERT-UPDATE-DELETE` gibi DML işlemleridir.
            Trigger içerisinde sanal olarak oluşan Inserted ve Deleted tabloları vardır.
            Inserted tablosu yeni eklenen ya da güncellenen kaydın yeni değerini tutar, deleted tablosu da silineni tutar.
        Index, bizim belirlediğimiz sütunlara göre sıralı şekilde saklanmasını sağlayan ve sorgu hızı arttıran nesnedir.
        Table scan, bir tablo içerisindeki minik sayfaların rastgele incelenmesidir, tabloda birincil anahtar yoksa yapılır.
        Clustered Index, bir tabloda birincil anahtar varsa o otomatik olarak bir indeks olur ve sıralama yapılır.
        Non-Clustered Index, belli sütunların bir kopyasının sıralı bir şekilde tutulmasına denir, birden fazla eklenebilir.
        Örnek kullanımlar:
            IF @EXAMRESULT>60
                SET @STATUS='BAŞARILI'
            ELSE
                SET @STATUS='BAŞARISIZ'
            ...
            SELECT 
            CASE 
                WHEN AGE<35 THEN 'GENÇ'
                WHEN AGE ...
            END AS AGEGROUP, *
            ...
            SELECT
            IIF(GENDER='E', 'ERKEK', 'KADIN') AS GENDEREXP,
            * FROM CUSTOMERS
            ...
            DECLARE @I AS INT=0
            WHILE @I<10
            BEGIN
                ...
                SET @I=@I+1
            END
            ...
            CREATE TRIGGER TRGCUSTOMERINSERT
            ON CUSTOMERS 
            AFTER INSERT 
            AS 
            BEGIN 
            ...
            END
            ...
            CREATE INDEX IX1 ON CUSTOMERS 
            (NAMESURNAME)
            ...

<br></br>
## 24- `HTML`:
        HyperText Markup Language, web sayfalarının yapısal içeriğini tanımlayan bir işaretleme dilidir. 
        Etiketler ve bunların içerisinde attribute'lar bulunur, etiketler genellikle <tag> ... </tag> şeklinde kullanılır.
        <!DOCTYPE HTML>, bir HTML belgesinin hangi sürümünü ve standartlarını kullanacağını belirten doküman türü tanımıdır.
        <html>, HTML belgesinin başlangıcını belirten temel etikettir, ör: <html lang="en">.
        <head>, HTML belgesinde başlık, meta bilgiler, stil tanımları, bağlantılar ve diğer önemsiz içerikleri içerir.
        <body>, kullanıcı tarafından görülebilen tüm içerik, metinler, resimler, bağlantılar, tablolar ve formlar buradadır.
        <style>, CSS kurallarını tanımlamak için kullanılan yapısal etikettir, ör: <style> h1 { text-align: center; } </style>.
        <link>, belge içinde harici bir kaynağa bağlantı yapmak için kullanılır, ör: <link rel="stylesheet" href=styles.css>.
        <meta>, belgenin karakter seti, dil, tarayıcı uyumluluğu ve diğer meta bilgileri içerir, ör: <meta charset="UTF-8">.
        <h>, başlık elementlerini belirtmek için kullanılır, <h1> en yüksek düzeyi belirtirken <h6> en düşüğü belirtir.
        <p>, paragraf elementini belirtmek için kullanılır, metin içeriğini paragraflara böler.
        <!--  ...  -->, arasına yazılan metin HTML belgesinde yorum satırı olarak kabul edilir.
        <main>, HTML belgesinde ana içerik bölümünü tanımlar, genellikle bir sayfa içerisinde yalnızca bir tane bulunur. 
        <img src="..." alt="...">, HTML belgelerinde resimleri göstermek için kullanılır.
        <a href="...">Bağlantı Metni</a>, anchor etiketi HTML belgelerinde bağlantılar oluşturmak için kullanılır.
        <section>, sayfanın belli bir bölümünü temsil edip gruplandırmaya yarar.
        <ul>, HTML belgelerinde sırasız liste oluşturmak için kullanılır, içerisine <li>...</li> maddeleri koyulabilir.
        <figure>, HTML belgelerinde bir resim, grafik, çizelge gibi içerikleri gruplamak için kullanılır.
            <figcaption>, genellikle <figure> içerisinde kullanılır ve bu medyanın açıklamasını temsil eder.
        <em>, HTML belgelerinde metin içinde vurgulanmış bir kısmı temsil etmek için kullanılan içeriksel bir etikettir.
        <ol>, sıralı listeyi temsil eder, yine içerisinde <li> maddeleri kullanılır ve bu sefer numaralandırılmışlardır.
        <strong>, HTML belgelerinde metin içinde önemli veya güçlü vurgulanmış kısmı temsil eder.
        <form>, kullanıcıdan bilgi toplamak veya belirli bir eylemi gerçekleştirme olanağı tanımak için kullanılır.
            `action` attribute, form verisinin nereye gönderileceğini belirtir, ör: <form action="..."></form>
            <input>, veri girişi alır, <input type="text(or radio)" name="user" id="..." placeholder="Hey" required>.
            <button>, form içerisinde tıklanabilir görevi görür, ör: <button type="submit">Gönder</button>.
            <fieldset>, benzer form elemanlarını bir araya getirmek için kullanılır, ör: <fieldset> <legend>..</fieldset>.
        <footer>, HTML belgelerinde sayfanın alt kısmında bulunan bir altbilgi etiketidir.
        <div>, belirli bir bölgenin içeriğini gruplamak ve stil uygulamak için kullanılır, içindeki `class` ile kullanılır. 
            Ör: <div class="container" id="benimDiv"> <p>...</p> </div>.
        <article>, bir belgede bağımsız, tek bir içerik parçasını veya kompozisyonu ifade eden bir yapısal etikettir.
        `<hr>`, yatay bir çizgi çizen boşluk bırakır, `<br>` da bir boş satır bırakır.
        `<select>` ve `<option>`, bir web formu içerisinde kullanıcının seçim yapmasını sağlarlar.
             Ör: <select>  <option value="..."></option> ... </select>.
        `<textarea>`, birden çok satırdan oluşan metinlerin girişi için kullanılan form elemanıdır, ör: <textarea>...</.>.
